# https://www.quantstart.com/articles/Event-Driven-Backtesting-with-Python-Part-IV

import datetime
import numpy as np
import pandas as pd
import queue

from abc import ABCMeta, abstractmethod

from event import SignalEvent

class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")


class BuyAndHoldStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, events):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object.
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)
                if bars is not None and bars != []:
                    if self.bought[s] == False:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG', 1)
                        self.events.put(signal)
                        self.bought[s] = True

# will send exit orders if risk or target are met.
# i.e. if last price is risk cents lower than our initial long
# or if last price is greater than target cents
class VolumeBar3(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, port, events, risk, target, study):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.port = port
        self.risk = risk
        self.target = target
        self.study = study
        self.wait_bars = 4

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def send_exit(self, bars):
        check_risk, check_target = False, False
        if self.port.trade_activity[-1][2] == "LONG":
            check_risk = (self.port.trade_activity[-1][4] - bars[0][5] >= self.risk)
            check_target = (bars[0][5] - self.port.trade_activity[-1][4] >= self.target)
        elif self.port.trade_activity[-1][2] == "SHORT":
            check_target = (self.port.trade_activity[-1][4] - bars[0][5] >= self.target)
            check_risk = (bars[0][5] - self.port.trade_activity[-1][4] >= self.risk)

        return check_risk or check_target

    def wait_period(self, s):
        return len(self.study.data[s]) > self.wait_bars

    def send_entry(self, s):
        study = self.study.data[s]

        go_short = sum(list(v[1] - v[4] > 0 for v in study[-4:-1])) == 3
        go_long = sum(list(v[1] - v[4] < 0 for v in study[-4:-1])) == 3
        if go_long:
            return 1
        if go_short:
            return -1

    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object.
        """

        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)

                if bars is not None and bars != [] and self.wait_period(s):
                    if not self.bought[s] and self.send_entry(s) == 1:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG', 1)
                        self.events.put(signal)
                        self.bought[s] = True

                    elif not self.bought[s] and self.send_entry(s) == -1:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT', 1)
                        self.events.put(signal)
                        self.bought[s] = True

                    elif self.bought[s]:
                        if self.send_exit(bars):
                            signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT', 1)
                            self.events.put(signal)
                            self.bought[s] = False
                            self.wait_bars = len(self.study.data[s])


class VolumeProfile(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, port, events, risk, target, study):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.port = port
        self.risk = risk
        self.target = target
        self.study = study
        self.wait = 10000
        self.total_volume = 0

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def profile_to_df(self):
        self.study = pd.DataFrame.from_dict(self.study.data[s], 'index')
        self.study = study.reset_index()
        self.study.columns = ["Price", "Volume"]

    def send_exit(self, bars):
        check_risk, check_target = False, False
        if self.port.trade_activity[-1][2] == "LONG":
            check_risk = (self.port.trade_activity[-1][4] - bars[0][5] >= self.risk)
            check_target = (bars[0][5] - self.port.trade_activity[-1][4] >= self.target)
        elif self.port.trade_activity[-1][2] == "SHORT":
            check_target = (self.port.trade_activity[-1][4] - bars[0][5] >= self.target)
            check_risk = (bars[0][5] - self.port.trade_activity[-1][4] >= self.risk)

        return check_risk or check_target

    def wait_period(self, s):
        # returns boolean to wait
        # calculates total volume of the time period.
        # must be greater than initial self.wait threshold to consider a trade
        # once we trade and exit, must then wait
        study = self.study.data[s]
        self.total_volume = sum(v for k,v in study.items())
        wait = self.total_volume < self.wait
        return wait

    def send_entry(self, s):
        # checks to see if current price is a value_area number
        # places order with appropriate direction

        # value_areas = [[XXXX, XXXX, XXXX], [T, T, T]]
        value_areas = self.study.value_areas["CL"]
        bars = self.bars.get_latest_bars(s, N=1)

        if bars[0][5] in value_areas[0]:
            # grabs direction of price relative to each value_are number
            # TRUE means price is coming from below
            if value_areas[1][value_areas[0].index(bars[0][5])]:
                return 1
            else:
                return -1

    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object.
        """

        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)

                # is there a valid bar and should we be not waiting for more bars
                if bars is not None and bars != [] and not self.wait_period(s):
                    if not self.bought[s] and self.send_entry(s) == 1:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG', 1)
                        self.events.put(signal)
                        self.bought[s] = True
                    elif not self.bought[s] and self.send_entry(s) == -1:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT', 1)
                        self.events.put(signal)
                        self.bought[s] = True

                    # if we already have a position
                    elif self.bought[s]:
                        if self.send_exit(bars):
                            signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT', 1)
                            self.events.put(signal)
                            self.bought[s] = False

                            # must wait an additional 2000volume before reentering a trade
                            self.wait = self.total_volume + 2000


class RangeBar(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, port, events, risk, target, study):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.port = port
        self.risk = risk
        self.target = target
        self.study = study
        self.wait_bars = 1

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def send_exit(self, bars):
        check_risk, check_target = False, False
        if self.port.trade_activity[-1][2] == "LONG":
            check_risk = (self.port.trade_activity[-1][4] - bars[0][5] >= self.risk)
            check_target = (bars[0][5] - self.port.trade_activity[-1][4] >= self.target)
        elif self.port.trade_activity[-1][2] == "SHORT":
            check_target = (self.port.trade_activity[-1][4] - bars[0][5] >= self.target)
            check_risk = (bars[0][5] - self.port.trade_activity[-1][4] >= self.risk)

        return check_risk or check_target

    def wait_period(self, s):
        return len(self.study.data[s]) > self.wait_bars

    def send_entry(self, s):
        study = self.study.data[s][-1][1]
        prices = sorted(list(k for k, v in study.items()))
        vol = list(sum(study[p]) for p in prices)

        total_vol = sum(vol)
        if len(prices) > 4 and total_vol > 3000:
            if study[prices[0]][1] == 0:
                bottom_vol = sum([vol[0], vol[1]])
                go_long = (bottom_vol < 200) and bottom_vol < total_vol * .3
                if go_long: return 1

            elif study[prices[-1]][0] == 0:
                top_vol = sum([vol[-1], vol[-2]])
                go_short = (top_vol < 200) and top_vol < total_vol * .3
                if go_short: return -1

    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object.
        """

        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)

                if bars is not None and bars != [] and self.wait_period(s):
                    if not self.bought[s] and self.send_entry(s) == 1:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG', 1)
                        print(self.study.data[s])
                        self.events.put(signal)
                        self.bought[s] = True

                    elif not self.bought[s] and self.send_entry(s) == -1:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT', 1)
                        self.events.put(signal)
                        self.bought[s] = True

                    elif self.bought[s]:
                        if self.send_exit(bars):
                            signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT', 1)
                            self.events.put(signal)
                            self.bought[s] = False
                            self.wait_bars = len(self.study.data[s])

