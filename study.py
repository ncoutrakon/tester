class Study(object):
    """
    Study is an abstract base class providing an interface for
    all subsequent (inherited) studies handling objects.

    The goal of a (derived) Study object is to restructure the inputs of Bars
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Study object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """
    pass

class VolumeBars(Study):
    def __init__(self, bars, volume):

        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.data = self.construct_all_studies()
        self.volume = volume

    def construct_all_studies(self):
        """
        Constructs the volume bars list using the start_date
        to determine when the time index will begin.
        """
        d = dict((k, v) for k, v in [(s, [[0, 0, 0, 0, 0, 0]]) for s in self.symbol_list])
        return d

    def calculate(self, bars, study):
        sym, time, open_px, high, low, close, vol = bars[0]
        vol_counter = study[-1][5]

        if vol_counter == 0:
            study.append([time, close, high, low, close, vol])

        elif vol_counter + vol <= self.volume:
            study[-1][4] = close

            # updates new high, low for each volume bar
            study[-1][2] = max(study[-1][2], high)
            study[-1][3] = min(study[-1][3], low)

            vol_counter += vol
            study[-1][5] = vol_counter

        # if vol_counter will be greater than volume parameter
        # adds volume up to volume parameter to current bar and
        # creates a new bar
        elif vol_counter + vol > self.volume:
            study[-1][2] = max(study[-1][2], high)
            study[-1][3] = min(study[-1][3], low)

            study[-1][4] = close
            study[-1][5] = self.volume
            vol = vol_counter + vol - self.volume
            study.append([time, close, high, low, close, vol])

        return study

    def update(self):
         for s in self.symbol_list:
            bars = self.bars.get_latest_bars(s, N=1)
            if bars is not None and bars != []:
                self.data[s] = self.calculate(bars, self.data[s])


class VolumeProfile(Study):
    def __init__(self, bars):

        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.data = self.construct_all_studies()

        # VAL, POC, VAH
        self.value_areas = self.construct_value_areas()

    def construct_all_studies(self):
        """
        Constructs the volume bars list using the start_date
        to determine when the time index will begin.
        """

        d = dict((k, v) for k, v in [(s, {}) for s in self.symbol_list])

        return d

    def construct_value_areas(self):
        """
        Constructs the volume bars list using the start_date
        to determine when the time index will begin.
        """

        d = dict((k, v) for k, v in [(s, [0, 0, 0]) for s in self.symbol_list])

        return d

    def calculate(self, bars, study):
        sym, time, open_px, ask, bid, trade_px, vol = bars[0]

        # tallys volume traded on bid
        if trade_px not in study:
            study[trade_px] = vol
        else:
            study[trade_px] += vol

        return study

    def get_value_areas(self, bars, study):
        total_volume = sum(v for k,v in study.items())
        va_threshold = .7*total_volume
        poc = max(study, key=(lambda key: study[key]))
        va_volume = study[poc]
        val, vah = poc - 1, poc + 1
        i = 1
        while va_volume < va_threshold:
            val = poc - i
            vah = poc +i
            if val in study: va_volume += study[val]
            if vah in study: va_volume += study[vah]
            i += 1
        value_areas = [val, poc, vah]
        value_area_status = list(bars[0][5] < i for i in value_areas)

        return [value_areas, value_area_status]

    def update(self):
         for s in self.symbol_list:
            bars = self.bars.get_latest_bars(s, N=1)
            if bars is not None and bars != []:
                self.data[s] = self.calculate(bars, self.data[s])
                self.value_areas[s] = self.get_value_areas(bars, self.data[s])

class RangeBars(Study):
    def __init__(self, bars, range_length):

        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.data = self.construct_all_studies()
        self.range = range_length

    def construct_all_studies(self):
        """
        Constructs the volume bars list using the start_date
        to determine when the time index will begin.
        """
        d = dict((k, v) for k, v in [(s, [[ (), () ]] ) for s in self.symbol_list])
        return d

    def calculate(self, bars, study):
        sym, time, open_px, high, low, close, vol = bars[0]
        bid_vol, ask_vol = (close <= low) * vol, (close >= high) * vol * (low != high)

        range_time = study[-1][0]
        range_slice = study[-1][1]

        if not range_time:
            print("New")
            range_time = time
            range_slice = {close: [0, 0]}


        prices = list(k for k, v in range_slice.items())
        prices.append(close)
        range_counter = max(prices) - min(prices)
        print([prices, range_counter])

        if range_counter < self.range:
            if close in range_slice:
                bid_vol += range_slice[close][0]
                ask_vol += range_slice[close][1]

            range_slice[close] = [bid_vol, ask_vol]
            print(range_slice)
            study[-1] = [range_time, range_slice]
        else:
            study.append([time, {close: [bid_vol, ask_vol]}])

        return study

    def update(self):
         for s in self.symbol_list:
            bars = self.bars.get_latest_bars(s, N=1)
            if bars is not None and bars != []:
                self.data[s] = self.calculate(bars, self.data[s])
