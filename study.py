class Study(object):
    """
    Study is an abstract base class providing an interface for
    all subsequent (inherited) studies handling objects.

    The goal of a (derived) Study object is to restructure the inputs of Bars
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Study object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """
    pass

class VolumeBars(Study):
    def __init__(self, bars, volume):

        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.data = self.construct_all_studies()
        self.volume = volume

    def construct_all_studies(self):
        """
        Constructs the volume bars list using the start_date
        to determine when the time index will begin.
        """
        d = dict((k, v) for k, v in [(s, [[0, 0, 0, 0, 0, 0]]) for s in self.symbol_list])
        return d

    def calculate(self, bars, study):
        sym, time, open_px, high, low, close, vol = bars[0]
        vol_counter = study[-1][5]

        if vol_counter == 0:
            study.append([time, close, high, low, close, vol])

        elif vol_counter + vol <= self.volume:
            study[-1][4] = close

            # updates new high, low for each volume bar
            study[-1][2] = max(study[-1][2], high)
            study[-1][3] = min(study[-1][3], low)

            vol_counter += vol
            study[-1][5] = vol_counter

        # if vol_counter will be greater than volume parameter
        # adds volume up to volume parameter to current bar and
        # creates a new bar
        elif vol_counter + vol > self.volume:
            study[-1][2] = max(study[-1][2], high)
            study[-1][3] = min(study[-1][3], low)

            study[-1][4] = close
            study[-1][5] = self.volume
            vol = vol_counter + vol - self.volume
            study.append([time, close, high, low, close, vol])

        return study

    def update(self):
         for s in self.symbol_list:
            bars = self.bars.get_latest_bars(s, N=1)
            if bars is not None and bars != []:
                self.data[s] = self.calculate(bars, self.data[s])


class VolumeProfile(Study):
    def __init__(self, bars):

        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.data = self.construct_all_studies()

        # VAL, POC, VAH
        self.value_areas = self.construct_value_areas()

    def construct_all_studies(self):
        """
        Constructs the volume bars list using the start_date
        to determine when the time index will begin.
        """

        d = dict((k, v) for k, v in [(s, {}) for s in self.symbol_list])

        return d

    def construct_value_areas(self):
        """
        Constructs the volume bars list using the start_date
        to determine when the time index will begin.
        """

        d = dict((k, v) for k, v in [(s, [0, 0, 0]) for s in self.symbol_list])

        return d

    def calculate(self, bars, study):
        sym, time, open_px, ask, bid, trade_px, vol = bars[0]

        # tallys volume traded on bid
        if trade_px not in study:
            study[trade_px] = vol
        else:
            study[trade_px] += vol

        return study

    def get_value_areas(self, bars, study):
        total_volume = sum(v for k,v in study.items())
        va_threshold = .7*total_volume
        poc = max(study, key=(lambda key: study[key]))
        va_volume = study[poc]
        val, vah = poc - 1, poc + 1
        i = 1
        while va_volume < va_threshold:
            val = poc - i
            vah = poc +i
            if val in study: va_volume += study[val]
            if vah in study: va_volume += study[vah]
            i += 1
        value_areas = [val, poc, vah]
        value_area_status = list(bars[0][5] < i for i in value_areas)

        return [value_areas, value_area_status]

    def update(self):
         for s in self.symbol_list:
            bars = self.bars.get_latest_bars(s, N=1)
            if bars is not None and bars != []:
                self.data[s] = self.calculate(bars, self.data[s])
                self.value_areas[s] = self.get_value_areas(bars, self.data[s])

